var documenterSearchIndex = {"docs":
[{"location":"profile/#Using-FHIR-Profiles","page":"Profile","title":"Using FHIR Profiles","text":"","category":"section"},{"location":"profile/","page":"Profile","title":"Profile","text":"This package demonstrates how to query bundles of FHIR using DataKnots with a 116 person synthetic dataset. First we import the relevant  libraries we'll be using.","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"using JSON\nusing Dates\nusing DataKnots\nusing DataKnots4FHIR\nusing Pkg.Artifacts","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"Next let's build an in-memory database that holds our synthetic patient bundles. Note that the downloaded data includes two additional bundles, for providers and hospitals.","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"datapath = joinpath(artifact\"synthea-116\", \"synthea-116\");\n\nitems = []\nfor fname in readdir(datapath)\n    item = JSON.parsefile(joinpath(datapath, fname))\n    push!(items, item)\nend\n\ndb = convert(DataKnot, (bundle=items, ) )\n#=>\n│ bundle                                                             …\n┼────────────────────────────────────────────────────────────────────…\n│ Dict{String,Any}(\\\"entry\\\"=>Any[Dict{String,Any}(\\\"fullUrl\\\"=>\\\"urn…\n=#\n\n@query db count(bundle)\n#=>\n┼─────┼\n│ 118 │\n=#","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"Then, we could define some FHIR profiles to work with it. For example, we could ask, \"What are the total number of Patient resources?\"","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"Bundle = FHIRProfile(:R4, :Bundle)\nPatient = FHIRProfile(:R4, :Patient)\nObservation = FHIRProfile(:R4, :Observation)\nCondition = FHIRProfile(:R4, :Condition)\n\n@query db count(bundle.$Bundle.entry.resource.$Patient) \n#=>\n┼─────┼\n│ 116 │\n=#","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"Let's refine our bundle to pull out the things we're interested in seeing. First, we're only interested in bundles that have a patient entry in them. Then, let's group patents and observations and see how many observations we have for each patient.","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"Bundle =\n   It.bundle >>\n   FHIRProfile(:R4, :Bundle) >>\n   Filter(Exists(It.entry.resource >> Patient)) >>\n   Record(\n    :patient => It.entry.resource >> Patient >> Is0to1,\n    :condition => It.entry.resource >> Condition,\n    :observation => It.entry.resource >> Observation )\n\n@query db $Bundle{patient.id, no_obs => count(observation),\n                              no_cnd => count(condition)}\n#=>\n    │ Bundle                                               │\n    │ id                                    no_obs  no_cnd │\n────┼──────────────────────────────────────────────────────┼\n  1 │ 31f1152b-6f91-4b0b-b7d3-67af683a7216     156       8 │\n  2 │ 6f882e03-5e1d-4c04-8507-29ddfc0548bb     123      13 │\n  ⋮\n116 │ e43e35c8-4ee6-4ad6-a195-a92afaeda66b      49      10 │\n=#","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"Since we're unfamilar with this database, we could see what sort of observations were made. It seems not very much variety, but this is synthetic data.","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"@query db begin\n    $Bundle.observation.valueCodeableConcept\n    group(coding{code, display})\n    {coding, count=>count(valueCodeableConcept)}\nend\n#=>\n   │ coding{code,display}                                count │\n───┼───────────────────────────────────────────────────────────┼\n 1 │ 10828004, Positive (qualifier value)                   10 │\n 2 │ 109838007, Overlapping malignant neoplasm of colon      1 │\n⋮\n34 │ 87433001, Pulmonary emphysema (disorder)                1 │\n35 │ 95281009, Sudden Cardiac Death                          3 │\n=#","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"Let's see what sort of conditions are assigned.","category":"page"},{"location":"profile/","page":"Profile","title":"Profile","text":"@query db begin\n           $Bundle.condition.code\n           group(coding{code, display})\n           {coding, count=>count(code)}\nend\n#=>\n    │ coding{code,display}                                      count │\n────┼─────────────────────────────────────────────────────────────────┼\n  1 │ 10509002, Acute bronchitis (disorder)                        57 │\n  2 │ 109838007, Overlapping malignant neoplasm of colon            1 │\n  3 │ 124171000119105, Chronic intractable migraine without au…     4 │\n  ⋮\n124 │ 87628006, Bacterial infectious disease (disorder)             3 │\n125 │ 88805009, Chronic congestive heart failure (disorder)         1 │\n=#","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"This package is an application of the DataKnots processing system to Health Level 7 (HL7) Fast Healthcare Interoperability Resources (FHIR). This project creates schema-driven DataKnot queries for each FHIR profile, giving convenient access to JSON encoded FHI.","category":"page"},{"location":"overview/#Quick-Start","page":"Overview","title":"Quick Start","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Let's start with an example FHIR resource encoded using JSON, example patient. This resource could could be downloaded to a temporary file as follows.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"fname = download(\"https://www.hl7.org/fhir/R4/patient-example.json\")","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Alternatively, we've packaged the R4 FHIR specification, with examples, as Julia Artifact so they can be accessed via artifact\"fhir-r4\".","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Pkg.Artifacts\n\nfname = joinpath(artifact\"fhir-r4\", \"fhir-r4\", \"patient-example.json\")\n#-> …/fhir-r4/patient-example.json\"","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Regardless, the content for this downloaded file is JSON. It could be read directly and printed to the terminal.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"println(read(fname, String))\n#=>\n{\n  \"resourceType\": \"Patient\",\n  \"id\": \"example\",\n⋮\n  \"name\": [\n    {\n      \"use\": \"official\",\n      \"family\": \"Chalmers\",\n⋮\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We can then then use the JSON module to parse it. This will return a top-level dictionary.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using JSON\n\nresource = JSON.parsefile(fname)\ndisplay(resource)\n#=>\nDict{String,Any} with 14 entries:\n  \"active\"               => true\n  \"managingOrganization\" => Dict{String,Any}(\"reference\"=>\"Organizati…\n  \"address\"              => Any[Dict{String,Any}(\"line\"=>Any[\"534 Ere…\n  \"name\"                 => Any[Dict{String,Any}(\"family\"=>\"Chalmers\"…\n⋮\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Querying this structure could be done with native Julia. The following would return family names listed for this patient resource.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"[item[\"family\"]\n for item in resource[\"name\"]\n if haskey(item, \"family\") ]\n#=>\n[\"Chalmers\", \"Windsor\"]\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To more easily query this resource, let's use DataKnots and an adapter to FHIR data sources.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using DataKnots\nusing DataKnots4FHIR","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"However, since JSON is schemaless, DataKnots can't easily work with it directly. If we convert this input to a DataKnot, we'll see it's not fully converted into something usable.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"resource = convert(DataKnot, JSON.parsefile(fname))\n#=>\n┼────────────────────────────────────────────────────────────────────…\n│ Dict{String,Any}(\\\"active\\\"=>true,\\\"managingOrganization\\\"=>Dict{St…\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The FHIRProfile query constructor provides the needed schema by converting the FHIR resource definition from the HL7 specification.  For example, let's build a query reflecting the the FHIR R4 Patient profile. What the Patient query does is rather involved, so we'll skip that for now, using the semicolon to suppress printing its definition.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Patient = FHIRProfile(:R4, \"Patient\");","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"With this Patient query, the above inquiry, we can once again list all of the family names used by the patient resource. This example uses the DataKnots macro syntax; where the Patient query is referenced using the dollar sign ().","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource $Patient.name.family\n#=>\n  │ family   │\n──┼──────────┼\n1 │ Chalmers │\n2 │ Windsor  │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"With this syntax, the name field in each Patient is defined by the HumanName element. With this Patient schema query, the incoming data knot is structured so that it could be intelligibly queried. For example, we could return all of the given names of this patient associated with the Windsor family name.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource $Patient.name.filter(family==\"Windsor\").given\n#=>\n  │ given │\n──┼───────┼\n1 │ Peter │\n2 │ James │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To make it easy to explore these profiles, we have a helper constructor, FHIRExample, which finds a specification example by its identifier, loads it as JSON, and converts it into a DataKnot for us. Hence, the following is the minimal code needed to get up-and-running.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using DataKnots\nusing DataKnots4FHIR\n\nPatient = FHIRProfile(:R4, \"Patient\");\nresource = FHIRExample(:R4, \"Patient\", \"example\");\n\n@query resource $Patient\n#=>\n│ Patient                                                            …\n│ resource… id       meta{id,… implicit… language  text{id,… containe…\n┼────────────────────────────────────────────────────────────────────…\n│ Patient   example                                missing,…         …\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"What exactly does the Patient profile do?","category":"page"},{"location":"overview/#Profile-Queries","page":"Overview","title":"Profile Queries","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Directly querying a JSON encoded FHIR resource is challenging. Since JSON is schemaless, we don't know in advance if a given data element is a scalar value represented as a String or Integer or a nested structure represented as aDict or some other kind of object We can use DataKnotsshow(as=:shape, knot)`` function to look at the structure of a dataknot.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"show(as=:shape, resource)\n#=>\n1-element DataKnot:\n  #  Dict{String,Any}\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"DataKnots lets us query dictionaries by key. Hence, we could return the resourceType of this FHIR resource.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource resourceType\n#=>\n│ resourceType │\n┼──────────────┼\n│ Patient      │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"However, things get complex when we try to return the list of name elements associated with the resource. Suppose we want to return a list of family names, one might try to write namefamily.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource name.family\n#=>\nERROR: cannot find \"family\" at\n(1:1) × Any\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"DataKnots cannot determine the output type of query resource name, and such it's listed as a singular value Any.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"show(as=:shape, @query resource name)\n#=>\n1-element DataKnot:\n  name  1:1 × Any\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"From inspection, we can see that the output is actually a vector of dictionaries.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource name\n#=>\n│ name                                                               …\n┼────────────────────────────────────────────────────────────────────…\n│ Any[Dict{String,Any}(\\\"family\\\"=>\\\"Chalmers\\\",\\\"given\\\"=>Any[\\\"Pete…\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"We could let DataKnots know that name is a vector of dictionaries using the Is combinator as follows.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@define isVector() = is(Vector{Any})\n@define isDict() = is(Dict{String, Any})\n@define isString() = is(String)\n\n@query resource name.isVector().isDict()\n#=>\n  │ name                                                             …\n──┼──────────────────────────────────────────────────────────────────…\n1 │ Dict{String,Any}(\\\"family\\\"=>\\\"Chalmers\\\",\\\"given\\\"=>Any[\\\"Peter\\…\n2 │ Dict{String,Any}(\\\"given\\\"=>Any[\\\"Jim\\\"],\\\"use\\\"=>\\\"usual\\\")     …\n3 │ Dict{String,Any}(\\\"family\\\"=>\\\"Windsor\\\",\\\"given\\\"=>Any[\\\"Peter\\\"…\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Then, we could return the list of family names; except this has its own problem. The second entry provides a nickname, and the family name is optional, shown here as missing, rather than being omitted.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource name.isVector().isDict().family\n#=>\n  │ family   │\n──┼──────────┼\n1 │ Chalmers │\n2 │ missing  │\n3 │ Windsor  │\n=#\n\nshow(as=:shape,\n  @query resource name.isVector().isDict().family)\n#=>\n3-element DataKnot:\n  family  0:N × Any\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"This can be addressed by specifying the datatype of family is UnionString Missing. In this case, DataKnots knows that the missing value should be omitted in the query result.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@define isOptString() = is(Union{String, Missing})\n\n@query resource name.isVector().isDict().family.isOptString()\n#=>\n  │ family   │\n──┼──────────┼\n1 │ Chalmers │\n2 │ Windsor  │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Providing this detail is what the Patient profile query does.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Patient = FHIRProfile(:R4, \"Patient\")\n@query resource $Patient.name.family\n#=>\n  │ family   │\n──┼──────────┼\n1 │ Chalmers │\n2 │ Windsor  │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"This typing information beings with it another benefit. By default operations on a dictionary return missing if a key is omitted. Hence, if you have a typo, such as, resoursType instead of resourceType, you'll get a missing value rather than an error.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource resoursType\n#=>\n│ resoursType │\n┼─────────────┼\n│ missing     │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"By applying the the Patient query, typos like this are errors.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource $Patient.resoursType\n#=>\nERROR: cannot find \"resoursType\" at\n(0:1) × (resourceType = (1:1) × String, …\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Moreover, this Patient profile can be used for introspection.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"show(as=:shape, @query resource $Patient.name)\n#=>\n3-element DataKnot:\n  name           0:N\n  ├╴id           0:1 × String\n  ├╴extension    0:N × Dict{String,Any}\n  ├╴use          0:1 × String\n  ├╴text         0:1 × String\n  ├╴family       0:1 × String\n  ├╴given        0:N × String\n⋮\n=#","category":"page"},{"location":"overview/#Exceptional-Cases","page":"Overview","title":"Exceptional Cases","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"These generated profiles are not perfect. They are quite large and the FHIR schema has cycles. Therefore, these profiles stop expanding once an element has been seen before. Moreover, extensions are not expanded. Sometimes access to extensions is needed. The \"newborn\"` specification example has an example of an extension.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"newborn = FHIRExample(:R4, \"Patient\", \"newborn\");\n\n@query newborn $Patient.extension\n#=>\n  │ extension                                                      …\n──┼────────────────────────────────────────────────────────────────…\n1 │ Dict{String,Any}(\\\"valueString\\\"=>\\\"Everywoman\\\",\\\"url\\\"=>\\\"htt…\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To work with the extension, we could use the Extension profile.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Extension = FHIRProfile(:R4, \"Extension\");\n\n@query newborn begin\n    $Patient.extension.$Extension.\n     filter(endswith(url, \"patient-mothersMaidenName\")).\n     valueString\nend\n#=>\n  │ valueString │\n──┼─────────────┼\n1 │ Everywoman  │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"It's often handy to convert these into a query, so they can be reused. We do this below using DataKnots' Julia syntax. We'll check for equality on the entire URL and additionally assert there is at most one result.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"MothersMaidenName = Is0to1(\n    It.extension >> Extension >>\n    Filter(It.url .== string(\"http://hl7.org/fhir/StructureDefinition/\",\n                             \"patient-mothersMaidenName\")) >>\n    It.valueString) >> Label(:mothersMaidenName);\n\n@query newborn $Patient.$MothersMaidenName\n#=>\n│ mothersMaidenName │\n┼───────────────────┼\n│ Everywoman        │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Sometimes scalar field values, such as birthDate have an extension; we do not represent these either. To permit access, at every level of the hierarchy, we provide a special underscore attribute that gives access to the underlying JSON source for that component.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource $Patient._\n#=>\n│ _                                                                  …\n┼────────────────────────────────────────────────────────────────────…\n│ Dict{String,Any}(\\\"active\\\"=>true,\\\"managingOrganization\\\"=>Dict{St…\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"From there, one could access the extension for birthDate.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query resource $Patient._._birthDate\n#=>\n│ _birthDate                                                         …\n┼────────────────────────────────────────────────────────────────────…\n│ Dict{String,Any}(\\\"extension\\\"=>Any[Dict{String,Any}(\\\"valueDateTim…\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"However, using the underlying Dict is complex. In particular, one must handle not only providing type information as described earlier, but also, convert missing values into empty lists using coalesce. There is a helper function that does this for you.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"BirthInfo = FHIRField(:R4, \"_birthDate\");\n\n@query resource $Patient.$BirthInfo\n#=>\n│ _birthDate                                                          │\n│ id  extension{id,extension,url,valueAddress{id,extension,use,type,t…│\n┼─────────────────────────────────────────────────────────────────────┼\n│     missing, [], http://hl7.org/fhir/StructureDefinition/patient-bi…│\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Using this, one could define another custom combinator.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"BirthTime = Is0to1(\n    FHIRField(:R4, \"_birthDate\") >> It.extension >>\n    Filter(It.url .== string(\"http://hl7.org/fhir/StructureDefinition/\",\n                             \"patient-birthTime\")) >>\n    It.valueDateTime) >> Label(:birthTime);\n\n@query newborn $Patient.$BirthTime\n#=>\n│ birthTime                 │\n┼───────────────────────────┼\n│ 2017-05-09T17:11:00+01:00 │\n=#","category":"page"},{"location":"overview/#DataType-Handling","page":"Overview","title":"DataType Handling","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"As part of the casting, date and time values are converted. This makes it easy to do date comparison.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Dates\n\nexample = FHIRExample(:R4, \"Patient\", \"example\")\n\n@query example $Patient.filter(birthDate<Date(\"1979-12-31\")).birthDate\n#=>\n│ birthDate  │\n┼────────────┼\n│ 1974-12-25 │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"However, since the underlying Julia implementation doesn't create an error if a string is compared to a date; therefore, you can have some rather unexpected behavior.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query example $Patient.filter(birthDate==\"1974-12-25\").id\n#=>\n│ id │\n┼────┼\n(empty)\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To get an actual match, a Date has to be constructed.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"@query example $Patient.filter(birthDate==Date(\"1974-12-25\")).id\n#=>\n│ id      │\n┼─────────┼\n│ example │\n=#","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"This could perhaps be addressed if we used the congruent operator?","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"≅(a::T, b::T) where {T} = a == b\n≅(a, b) = ≅(promote(a, b)...)\n\n@query example $Patient.filter(birthDate≅ Date(\"1974-12-25\")).id\n#=>\n│ id      │\n┼─────────┼\n│ example │\n=#\n\n@query example $Patient.filter(birthDate≅ \"1974-12-25\").id\n#=>\nERROR: cannot apply ≅ to Tuple{Union{Missing, Date},String}\n=#","category":"page"},{"location":"#DataKnots4FHIR.jl","page":"Home","title":"DataKnots4FHIR.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is an application of the DataKnots processing system to Health Level 7 (HL7) Fast Healthcare Interoperability Resources (FHIR). This project creates schema-driven DataKnot queries for each FHIR profile, giving convenient access to JSON encoded FHI.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"overview.md\",\n    \"profile.md\",\n    \"cms124v7.md\"\n]\nDepth=3","category":"page"},{"location":"cms124v7/#Clinical-Quality-Measure-(CQM)-Demonstration","page":"CMS124v7","title":"Clinical Quality Measure (CQM) Demonstration","text":"","category":"section"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"This workbook demonstrates how DataKnots could be used to construct a domain specific query language (DSQL) for modeling Clinical Quality Measures (CQMs). By modeling 4 electronic CQMs,  CMS104v8, CMS124v7, CMS125v7, and CMS130v7, we provide a direct comparison to the Clinical Quality Language (CQL). To get started, we must import modules relevant to our project.","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"using DataKnots\nusing DataKnots4FHIR\nusing Dates\nusing IntervalSets\nusing JSON\nusing Pkg.Artifacts","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"Next, let's create an in-memory test database with synthetic patient bundles. This Synthea dataset was provided via a HL7 connectathon. For each measure, this database consists of 20 patient records, 10 that are in the numerator of the eCQM (\"pass\"), and 10 that are not (\"fail\").","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"function build(measure::String, kind::String)\n    items = []\n    datapath = joinpath(artifact\"synthea-79\", \"synthea-79\",\n                        measure, kind)\n    for fname in readdir(datapath)\n        push!(items, JSON.parsefile(joinpath(datapath, fname)))\n    end\n    return items\nend\n\ndb = convert(DataKnot, (\n        CMS104_pass=build(\"CMS104v8\", \"numerator\"),\n        CMS104_fail=build(\"CMS104v8\", \"denominator\"),\n        CMS124_pass=build(\"CMS124v7\", \"numerator\"),\n        CMS124_fail=build(\"CMS124v7\", \"denominator\"),\n        CMS125_pass=build(\"CMS125v7\", \"numerator\"),\n        CMS125_fail=build(\"CMS125v7\", \"denominator\"),\n        CMS130_pass=build(\"CMS130v7\", \"numerator\"),\n        CMS130_fail=build(\"CMS130v7\", \"denominator\")))","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"We can then run any sort of DataKnot on these datasets. However, they cannot be directly queried because they are Dict structures.","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"@query db count(CMS124_pass)\n#=>\n┼────┼\n│ 10 │\n=#\n\n@query db CMS124_pass\n#=>\n   │ CMS124_pass                                                      │\n───┼──────────────────────────────────────────────────────────────────┼\n 1 │ Dict{String,Any}(\\\"entry\\\"=>Any[Dict{String,Any}(\\\"fullUrl\\\"=>\\\"…│\n 2 │ Dict{String,Any}(\\\"entry\\\"=>Any[Dict{String,Any}(\\\"fullUrl\\\"=>\\\"…│\n 3 │ Dict{String,Any}(\\\"entry\\\"=>Any[Dict{String,Any}(\\\"fullUrl\\\"=>\\\"…│\n ⋮\n 9 │ Dict{String,Any}(\\\"entry\\\"=>Any[Dict{String,Any}(\\\"fullUrl\\\"=>\\\"…│\n10 │ Dict{String,Any}(\\\"entry\\\"=>Any[Dict{String,Any}(\\\"fullUrl\\\"=>\\\"…│\n=#","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"We can unpack these structures into a more meaningful representation of this Fast Healthcare Interoperability Resources (FHIR). This querying approach requires careful conversion to each kind of FHIR Profile. Moreover, it is not optimial for representing quality measures.","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"@define bundle() = fhir_profile(\"STU3\", \"Bundle\")\n@define resource() = entry.resource.fhir_profile(\"STU3\", \"Resource\")\n\n@query db CMS124_pass.bundle().{\n            resource().group(resourceType).label(Resource).\n            {resourceType, count(Resource).label(count)}}\n#=>\n   │ Bundle                                                           │\n   │ Resource{resourceType,count}                                     │\n───┼──────────────────────────────────────────────────────────────────┼\n 1 │ Claim, 9; Condition, 1; Encounter, 9; ExplanationOfBenefit, 9; I…│\n 2 │ Claim, 9; Condition, 1; Encounter, 9; ExplanationOfBenefit, 9; I…│\n ⋮\n 9 │ Claim, 9; Condition, 1; Encounter, 9; ExplanationOfBenefit, 9; I…│\n10 │ Claim, 9; Condition, 1; Encounter, 9; ExplanationOfBenefit, 9; I…│\n=#","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"We can futher unpack these structures to something similar to the Quality Data Model (QDM).","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"@query db CMS124_pass.QDM.LaboratoryTestPerformed\n#=>\n   │ LaboratoryTestPerformed                                          │\n   │ code             value                 relevantPeriod            │\n───┼──────────────────────────────────────────────────────────────────┼\n 1 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-03-27T12:52:10..2018…│\n 2 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2019-02-20T12:52:10..2019…│\n ⋮\n26 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-03-01T14:02:25..2018…│\n27 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2019-02-24T14:02:25..2019…│\n=#","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"Let's load the eCQM.","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"include(\"cms124v7.jl\")\n#-> ⋮","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"To run a measure, we'll need to have a measure period; note that we want it to be an open interval on the right endpoint.","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"@define MeasurePeriod = interval(\"[2018-01-01..2019-01-01)\")","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"Let's unit-test a few queries to see that they return what we wish.","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"@query db CMS124_pass.QDM.PapTestWithin3Years\n#=>\n   │ PapTestWithin3Years                                              │\n   │ code             value                 relevantPeriod            │\n───┼──────────────────────────────────────────────────────────────────┼\n 1 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-03-27T12:52:10..2018…│\n 2 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-08-22T22:14:44..2018…│\n ⋮\n 9 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-05-09T09:05:14..2018…│\n10 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-03-01T14:02:25..2018…│\n=#\n\n@query db CMS124_pass.QDM.QualifyingEncounters\n#=>\n   │ QualifyingEncounters                                             │\n   │ code                  dischargeDisposition  relevantPeriod       │\n───┼──────────────────────────────────────────────────────────────────┼\n 1 │ 439740005 [SNOMEDCT]  439740005 [SNOMEDCT]  2018-03-27T12:52:10.…│\n 2 │ 439740005 [SNOMEDCT]  439740005 [SNOMEDCT]  2018-08-22T22:14:44.…│\n ⋮\n20 │ 439740005 [SNOMEDCT]  439740005 [SNOMEDCT]  2018-05-09T09:05:14.…│\n21 │ 439740005 [SNOMEDCT]  439740005 [SNOMEDCT]  2018-03-01T14:02:25.…│\n=#\n\n@query db CMS124_pass.QDM.PapTestWithin5Years\n#=>\n   │ PapTestWithin5Years                                              │\n   │ code             value                 relevantPeriod            │\n───┼──────────────────────────────────────────────────────────────────┼\n 1 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-03-27T12:52:10..2018…│\n 2 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-08-22T22:14:44..2018…│\n ⋮\n 9 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-05-09T09:05:14..2018…│\n10 │ 10524-7 [LOINC]  445528004 [SNOMEDCT]  2018-03-01T14:02:25..2018…│\n=#","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"For the expected failures, they are false for the numerator.","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"@query db CMS124_fail.QDM.{Numerator, Denominator, DenominatorExclusions}\n#=>\n   │ QDM                                           │\n   │ Numerator  Denominator  DenominatorExclusions │\n───┼───────────────────────────────────────────────┼\n 1 │     false         true                  false │\n 2 │     false         true                  false │\n ⋮\n 9 │     false         true                  false │\n10 │     false         true                  false │\n=#","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"For the expected numerator passes, we get all true.","category":"page"},{"location":"cms124v7/","page":"CMS124v7","title":"CMS124v7","text":"@query db CMS124_pass.QDM.{Numerator, Denominator, DenominatorExclusions}\n#=>\n   │ QDM                                           │\n   │ Numerator  Denominator  DenominatorExclusions │\n───┼───────────────────────────────────────────────┼\n 1 │      true         true                  false │\n 2 │      true         true                  false │\n ⋮\n 9 │      true         true                  false │\n10 │      true         true                  false │\n=#","category":"page"}]
}
